// Automatically generated by FrederoxDev/Reverse-Tools/CxxParser/HeaderGenerator.py
#pragma once
#include <vector>
#include "ChunkPos.hpp"
#include <optional>

class Dimension;
class BlockSource;
class Block;
class BlockSourceListener;
class EntityContext;
class BlockPos;
class Vec3;
class AutomaticID;
class GetCollisionShapeInterface;
class LevelChunk;
class Material;
class Actor;
class ILevel;
class ChunkSource;
class AABB;
class WeakRefT;
struct ActorBlockSyncMessage;
struct SharePtrRefTraits;
struct Bounds;
enum MaterialType;

class BlockSource {

public:
    virtual ~BlockSource();
    virtual const Block& getBlock(int x, int y, int z) const;
    virtual const Block& getBlock(const BlockPos& pos) const;
    virtual const Block& getBlock(const BlockPos& pos, unsigned int layer) const;

    // Failed to match '_ZNK11BlockSource14getBlockEntityERK8BlockPos'
    virtual void filler0();

    virtual const Block& getExtraBlock(const BlockPos& p) const;
    virtual const Block& getLiquidBlock(const BlockPos& p) const;
    virtual bool hasBlock(const BlockPos& pos) const;
    virtual bool containsAnyLiquid(const AABB& box) const;
    virtual bool containsMaterial(const AABB& box, MaterialType material) const;
    virtual bool isUnderWater(const Vec3& pos, const Block& block) const;
    virtual const Material& getMaterial(const BlockPos& pos) const;
    virtual const Material& getMaterial(int x, int y, int z) const;
    virtual bool hasBorderBlock(BlockPos pos) const;
    virtual LevelChunk* getChunkAt(const BlockPos& pos) const;
    virtual bool hasChunksAt(const Bounds& bounds, bool ignoreClientChunk) const;
    virtual bool hasChunksAt(const BlockPos& pos, int r, bool ignoreClientChunk) const;
    virtual bool hasChunksAt(const AABB& bb, bool ignoreClientChunk) const;

    // virtual AutomaticID<Dimension, int> getDimensionId() const;
    virtual void filler1();

    virtual void fetchAABBs(std::vector<AABB, std::allocator<AABB>>& shapes, const AABB& intersectTestBox, bool withUnloadedChunks) const;

    // Unknown Parameters, known options:
    // (const AABB& box, float* actualSurfaceOffset, bool withUnloadedChunks, IActorMovementProxy* entity)
    // (std::vector<AABB, std::allocator<AABB>>& shapes, const AABB& box, float* actualSurfaceOffset, bool withUnloadedChunks, optional_ref<const GetCollisionShapeInterface> entity)
    //virtual void fetchCollisionShapes(std::vector<AABB>&, const AABB&, bool, optional_ref<const GetCollisionShapeInterface>, std::vector<AABB>*) const;
    virtual void filler11();

    // virtual void fetchCollisionShapesAndBlocks(std::vector<BlockSourceVisitor::CollisionShape, std::allocator<BlockSourceVisitor::CollisionShape>>&, const AABB&, bool, optional_ref<const GetCollisionShapeInterface>, std::vector<AABB, std::allocator<AABB>>*) const;
    virtual void filler2();

    // virtual AABB getTallestCollisionShape(const AABB&, float*, bool intersectTestBox, optional_ref<const GetCollisionShapeInterface> actualSurfaceOffset) const;
    virtual void filler3();

    virtual float getBrightness(const BlockPos& pos) const;

    virtual std::vector<AABB, std::allocator<AABB>>& fetchAABBs_(const AABB& intersectTestBox, bool withUnloadedChunks);

    // Unknown Parameters, known options:
    // (const AABB& box, float* actualSurfaceOffset, bool withUnloadedChunks, IActorMovementProxy* entity)
    // (std::vector<AABB, std::allocator<AABB>>& shapes, const AABB& box, float* actualSurfaceOffset, bool withUnloadedChunks, optional_ref<const GetCollisionShapeInterface> entity)
    virtual std::vector<AABB, std::allocator<AABB>>& fetchCollisionShapes(const AABB&, bool, std::optional<const EntityContext>, std::vector<AABB, std::allocator<AABB>>*);

    // virtual WeakRef<BlockSource> getWeakRef();
    virtual void filler4();

    virtual void addListener(BlockSourceListener& l);
    virtual void removeListener(BlockSourceListener& l);

    // virtual gsl::span<gsl::not_null<Actor*>> fetchEntities(const Actor* except, const AABB& bb, bool useHitbox, bool getDisplayEntities);
    virtual void filler5();

    // Failed to match '_ZN11BlockSource13fetchEntitiesE9ActorTypeRK4AABBPK5ActorNSt3__18functionIFbPS4_EEE'
    virtual void filler6();

    virtual bool setBlock(const BlockPos& pos, const Block& block, int updateFlags, const ActorBlockSyncMessage* syncMsg, Actor* blockChangeSource);
    virtual short getMinHeight() const;
    virtual short getMaxHeight() const;

    // Failed to match '_ZNK11BlockSource12getDimensionEv'
    virtual void filler7();

    virtual const Dimension& getDimensionConst() const;

    // Failed to match '_ZN11BlockSource12getDimensionEv'
    virtual void filler8();

    virtual LevelChunk* getChunk(int x, int z) const;
    virtual LevelChunk* getChunk(const ChunkPos& pos) const;

    // Failed to match '_ZN11BlockSource8getLevelEv'
    virtual void filler9();

    virtual ILevel& getILevel() const;

    // Failed to match '_ZNK11BlockSource4clipERK4Vec3S2_b9ShapeTypeibbP5ActorRKNSt3__18functionIFbRKS_RK5BlockbEEE'
    virtual void filler10();

    virtual ChunkSource& getChunkSource();
    virtual bool isSolidBlockingBlock(const BlockPos& p) const;
    virtual bool isSolidBlockingBlock(int x, int y, int z) const;
    virtual bool areChunksFullyLoaded(const BlockPos& pos, int r) const;

    // Unknown Parameters
    virtual bool canDoBlockDrops() const;

    // Unknown Parameters
    virtual bool canDoContainedItemDrops() const;

    virtual bool isInstaticking(const BlockPos& pos) const;
};